{"version":3,"file":"react-css-modules.macro.js","sources":["../src/macro.js"],"sourcesContent":["const { createMacro } = require(\"babel-plugin-macros\");\nconst { name } = require(\"../package.json\");\n\nconst defaultConfig = {\n  enableMemo: true,\n}\n\nconst removeStyleNameAttr = path => {\n  path.node.openingElement.attributes = [\n    ...path.node.openingElement.attributes.filter(\n      attr => attr.name.name !== \"styleName\",\n    ),\n  ];\n};\n\nconst findClassNameAttr = path => {\n  return path.node.openingElement.attributes.find(\n    attr => attr.name.name === \"className\",\n  );\n};\n\nconst createClassNameAttr = (t, value) => {\n  return t.JSXAttribute(t.jsxIdentifier(\"className\"), value);\n};\n\nconst getStyleNameAttrPayload = (t, styleNameAttr) => {\n  if (t.isStringLiteral(styleNameAttr.value)) {\n    if (!styleNameAttr.value.value) {\n      return undefined;\n    }\n    const stringValueReplacement = styleNameAttr.value.value\n      .split(\" \")\n      .map(val => t.stringLiteral(val));\n    if (stringValueReplacement.length > 1) {\n      return t.arrayExpression(stringValueReplacement);\n    }\n\n    if (stringValueReplacement[0]) {\n      return stringValueReplacement[0];\n    }\n\n    return undefined;\n  }\n\n  return styleNameAttr.value.expression;\n};\n\nconst visitor = (t, getStyleNameIdentifier) => ({\n  JSXElement(path) {\n    if (path.node.openingElement.attributes.length) {\n      const styleNameAttr = path.node.openingElement.attributes.find(\n        attr => attr.name.name === \"styleName\",\n      );\n      if (styleNameAttr) {\n        removeStyleNameAttr(path);\n        const styleNameAttrPayload = getStyleNameAttrPayload(t, styleNameAttr);\n\n        const styleNameExp = t.callExpression(getStyleNameIdentifier, [\n          ...[styleNameAttrPayload].filter(Boolean),\n        ]);\n        const classNameAttr = findClassNameAttr(path);\n\n        if (classNameAttr) {\n          if (styleNameAttrPayload) {\n            if (t.isJSXExpressionContainer(classNameAttr.value)) {\n              classNameAttr.value = t.JSXExpressionContainer(\n                t.binaryExpression(\n                  \"+\",\n                  classNameAttr.value.expression,\n                  styleNameExp,\n                ),\n              );\n            }\n\n            if (t.isStringLiteral(classNameAttr.value)) {\n              classNameAttr.value = t.JSXExpressionContainer(\n                t.binaryExpression(\"+\", classNameAttr.value, styleNameExp),\n              );\n            }\n          }\n\n          path.node.openingElement.attributes = [classNameAttr];\n        } else {\n          const newClassNameAttr = createClassNameAttr(\n            t,\n            t.JSXExpressionContainer(styleNameExp),\n          );\n          path.node.openingElement.attributes = [newClassNameAttr];\n        }\n      }\n    }\n  },\n});\n\nconst getStylesArgument = path => path.parent.arguments[0];\n\nconst myMacro = ({ references, babel, config }) => {\n  console.log('config', config);\n  const marcoConfig = { ...defaultConfig, ...config };\n  const { macro = [] } = references;\n  const { types: t } = babel;\n  macro.forEach(referencePath => {\n    const stylesArgument = getStylesArgument(referencePath);\n    // stylesArgument.name = \"s\";\n    // console.log(stylesArgument);\n    if (!stylesArgument) {\n      throw \"Styles map argument must be provided\";\n    }\n\n    const programPath = referencePath.findParent(parentPath =>\n      parentPath.isProgram(),\n    );\n    referencePath.parentPath.remove();\n    const firstImportDeclarationNode = programPath\n      .get(\"body\")\n      .find(node => t.isImportDeclaration(node));\n\n    const firstNonImportDeclarationNode = programPath\n      .get(\"body\")\n      .find(node => !t.isImportDeclaration(node));\n\n    const getStyleNameIdentifier = programPath.scope.generateUidIdentifier(\n      \"getStyleName\",\n    );\n\n    const bindStyleNames = programPath.scope.generateUidIdentifier(\n      \"bindStyleNames\",\n    );\n\n    const bindImplementation = marcoConfig.enableMemo ? `${name}/dist/bindStyleNameMemo` : `${name}/dist/bindStyleNamePure`;\n    const helperImportDeclaration = t.importDeclaration(\n      [t.importDefaultSpecifier(bindStyleNames)],\n      t.stringLiteral(bindImplementation),\n    );\n\n    const bindedStylesDeclaration = t.variableDeclaration(\"const\", [\n      t.variableDeclarator(\n        getStyleNameIdentifier,\n        t.callExpression(bindStyleNames, [stylesArgument]),\n      ),\n    ]);\n\n    firstImportDeclarationNode.insertBefore(helperImportDeclaration);\n    firstNonImportDeclarationNode.insertBefore(bindedStylesDeclaration);\n\n    programPath.traverse(visitor(t, getStyleNameIdentifier));\n  });\n};\n\nexport default createMacro(myMacro, {configName: 'reactCssModulesMacro'});\n"],"names":["createMacro","require","name","defaultConfig","enableMemo","references","babel","config","console","log","marcoConfig","macro","t","types","forEach","referencePath","stylesArgument","parent","arguments","programPath","findParent","parentPath","isProgram","remove","firstImportDeclarationNode","get","find","node","isImportDeclaration","firstNonImportDeclarationNode","getStyleNameIdentifier","scope","generateUidIdentifier","bindStyleNames","bindImplementation","helperImportDeclaration","importDeclaration","importDefaultSpecifier","stringLiteral","bindedStylesDeclaration","variableDeclaration","variableDeclarator","callExpression","insertBefore","traverse","JSXElement","path","openingElement","attributes","length","styleNameAttr","attr","filter","removeStyleNameAttr","styleNameAttrPayload","isStringLiteral","value","stringValueReplacement","split","map","val","arrayExpression","expression","getStyleNameAttrPayload","styleNameExp","Boolean","classNameAttr","findClassNameAttr","isJSXExpressionContainer","JSXExpressionContainer","binaryExpression","newClassNameAttr","JSXAttribute","jsxIdentifier","createClassNameAttr","visitor","configName"],"mappings":"6qBAAQA,EAAgBC,QAAQ,uBAAxBD,YACAE,EAASD,QAAQ,mBAAjBC,KAEFC,EAAgB,CACpBC,YAAY,KAiJCJ,EArDC,gBAAGK,IAAAA,WAAYC,IAAAA,MAAOC,IAAAA,OACpCC,QAAQC,IAAI,SAAUF,OAChBG,iVAAmBP,KAAkBI,KACpBF,EAAfM,MACOC,EAAMN,EAAbO,kBADQ,MAEVC,QAAQ,SAAAC,OACNC,EAAmCD,EARNE,OAAOC,UAAU,OAW/CF,OACG,2CAGFG,EAAcJ,EAAcK,WAAW,SAAAC,UAC3CA,EAAWC,cAEbP,EAAcM,WAAWE,aACnBC,EAA6BL,EAChCM,IAAI,QACJC,KAAK,SAAAC,UAAQf,EAAEgB,oBAAoBD,KAEhCE,EAAgCV,EACnCM,IAAI,QACJC,KAAK,SAAAC,UAASf,EAAEgB,oBAAoBD,KAEjCG,EAAyBX,EAAYY,MAAMC,sBAC/C,gBAGIC,EAAiBd,EAAYY,MAAMC,sBACvC,kBAGIE,YAAiDhC,EAA5BQ,EAAYN,gEACjC+B,EAA0BvB,EAAEwB,kBAChC,CAACxB,EAAEyB,uBAAuBJ,IAC1BrB,EAAE0B,cAAcJ,IAGZK,EAA0B3B,EAAE4B,oBAAoB,QAAS,CAC7D5B,EAAE6B,mBACAX,EACAlB,EAAE8B,eAAeT,EAAgB,CAACjB,OAItCQ,EAA2BmB,aAAaR,GACxCN,EAA8Bc,aAAaJ,GAE3CpB,EAAYyB,SAlGA,SAAChC,EAAGkB,SAA4B,CAC9Ce,oBAAWC,MACLA,EAAKnB,KAAKoB,eAAeC,WAAWC,OAAQ,KACxCC,EAAgBJ,EAAKnB,KAAKoB,eAAeC,WAAWtB,KACxD,SAAAyB,SAA2B,cAAnBA,EAAKjD,KAAKA,UAEhBgD,EAAe,EA9CG,SAAAJ,GAC1BA,EAAKnB,KAAKoB,eAAeC,aACpBF,EAAKnB,KAAKoB,eAAeC,WAAWI,OACrC,SAAAD,SAA2B,cAAnBA,EAAKjD,KAAKA,QA4ChBmD,CAAoBP,OACdQ,EA9BkB,SAAC1C,EAAGsC,MAC9BtC,EAAE2C,gBAAgBL,EAAcM,OAAQ,KACrCN,EAAcM,MAAMA,iBAGnBC,EAAyBP,EAAcM,MAAMA,MAChDE,MAAM,KACNC,IAAI,SAAAC,UAAOhD,EAAE0B,cAAcsB,YAC1BH,EAAuBR,OAAS,EAC3BrC,EAAEiD,gBAAgBJ,GAGvBA,EAAuB,GAClBA,EAAuB,iBAM3BP,EAAcM,MAAMM,WAWQC,CAAwBnD,EAAGsC,GAElDc,EAAepD,EAAE8B,eAAeZ,IACjC,CAACwB,GAAsBF,OAAOa,WAE7BC,EA7CY,SAAApB,UACjBA,EAAKnB,KAAKoB,eAAeC,WAAWtB,KACzC,SAAAyB,SAA2B,cAAnBA,EAAKjD,KAAKA,OA2CQiE,CAAkBrB,MAEpCoB,EACEZ,IACE1C,EAAEwD,yBAAyBF,EAAcV,SAC3CU,EAAcV,MAAQ5C,EAAEyD,uBACtBzD,EAAE0D,iBACA,IACAJ,EAAcV,MAAMM,WACpBE,KAKFpD,EAAE2C,gBAAgBW,EAAcV,SAClCU,EAAcV,MAAQ5C,EAAEyD,uBACtBzD,EAAE0D,iBAAiB,IAAKJ,EAAcV,MAAOQ,MAKnDlB,EAAKnB,KAAKoB,eAAeC,WAAa,CAACkB,OAClC,KACCK,EA9DY,SAAC3D,EAAG4C,UACvB5C,EAAE4D,aAAa5D,EAAE6D,cAAc,aAAcjB,GA6DnBkB,CACvB9D,EACAA,EAAEyD,uBAAuBL,IAE3BlB,EAAKnB,KAAKoB,eAAeC,WAAa,CAACuB,QA0DxBI,CAAQ/D,EAAGkB,OAIA,CAAC8C,WAAY"}